這是一個非常關鍵的擴充階段！您現在是「手動盯著一個房間」，我們要變成「走廊上的警衛，巡視所有有動靜的房間」。

回答您的核心問題：

Robot 是否要先建立第一次 chatroom？

不用。 最好的流程是讓使用者主動敲 Robot。

當使用者在 Teams 搜尋您的 Robot 並傳送第一則訊息時，Microsoft Teams 會自動建立一個 Chat ID。您的程式只需要能「偵測」到這個新冒出來的 Chat ID 即可。

(當然，如果是 Robot 要主動去敲一個「從沒講過話」的人，Robot 才需要主動呼叫 API 建立聊天室)。

如何擴增更多聊天室？

您不能把所有 CHAT_ID 寫在 .env 裡（那樣維護不完）。

您需要改變策略：從「監聽單一 ID」變成「監聽所有列表」。

新的邏輯：兩層式輪詢 (Two-Step Polling)
我們不再死守一個 CHAT_ID，而是改用 /chats API 來獲取列表。

步驟 A (巡邏): 每隔幾秒，呼叫 GET /chats (並依照 lastUpdatedDateTime 排序)。這會列出 Robot 參與的所有聊天室。

步驟 B (檢查): 檢查列表中的每一個聊天室，看它的「最後更新時間」是否比我們上次檢查的時間還新。

步驟 C (讀取): 如果有變動，才針對那個特定的 chat_id 呼叫 GET /chats/{id}/messages 讀取內容。

修改後的程式碼 (polling-bot-multi.js)
這段程式碼會自動處理「多個使用者」同時跟 Robot 講話的情況。

您不需要在 .env 裡設定 CHAT_ID 了，只要有 CLIENT_ID, SECRET, ROPC 帳密即可。

JavaScript

require('dotenv').config();
const axios = require('axios');
const querystring = require('querystring');
const { marked } = require('marked'); // 用於 HTML 回覆

// .env 設定讀取
const {
    CLIENT_ID,
    CLIENT_SECRET,
    TENANT_ID,
    ROPC_USERNAME,
    ROPC_PASSWORD,
    POLL_INTERVAL_MS
} = process.env;

const GRAPH_ENDPOINT = 'https://graph.microsoft.com/v1.0';

// 1. 取得 Token (ROPC) - 與之前相同
async function getGraphToken_ROPC() {
    const tokenEndpoint = `https://login.microsoftonline.com/${TENANT_ID}/oauth2/v2.0/token`;
    const postData = {
        client_id: CLIENT_ID,
        scope: 'https://graph.microsoft.com/.default',
        grant_type: 'password',
        username: ROPC_USERNAME,
        password: ROPC_PASSWORD,
        client_secret: CLIENT_SECRET
    };

    try {
        const response = await axios.post(tokenEndpoint, querystring.stringify(postData), {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });
        return response.data.access_token;
    } catch (error) {
        console.error("Token 錯誤:", error.response ? error.response.data : error.message);
        return null;
    }
}

// 2. 變數：記錄每個聊天室「最後處理到的訊息 ID」
// 格式: { "chat_id_A": "message_id_1", "chat_id_B": "message_id_2" }
let chatCheckpoints = {}; 

// 紀錄 Robot 自己的 ID
let myUserId = null;

// 3. 取得自己的 ID (為了過濾自己的訊息)
async function getMyUserId(token) {
    const res = await axios.get(`${GRAPH_ENDPOINT}/me`, {
        headers: { 'Authorization': `Bearer ${token}` }
    });
    myUserId = res.data.id;
    console.log(`[System] Robot ID: ${myUserId}`);
}

// 4. [核心] 處理單一聊天室的訊息
async function processChatMessages(token, chatId) {
    try {
        // 讀取該聊天室最新一則訊息
        const url = `${GRAPH_ENDPOINT}/chats/${chatId}/messages?$orderby=createdDateTime desc&$top=1`;
        const res = await axios.get(url, { headers: { 'Authorization': `Bearer ${token}` } });
        
        if (!res.data.value || res.data.value.length === 0) return;

        const latestMsg = res.data.value[0];
        const msgId = latestMsg.id;

        // 檢查 Checkpoint: 如果這則訊息已經處理過，就跳過
        if (chatCheckpoints[chatId] === msgId) {
            return;
        }

        // 檢查發送者: 如果是 Robot 自己發的，就跳過
        const senderId = (latestMsg.from && latestMsg.from.user) ? latestMsg.from.user.id : null;
        if (senderId === myUserId) {
            // 更新 checkpoint，避免下次重複檢查
            chatCheckpoints[chatId] = msgId;
            return;
        }

        // --- 處理新訊息 ---
        const senderName = latestMsg.from.user.displayName;
        const content = (latestMsg.body.content || '').replace(/<[^>]*>/g, '').trim();

        console.log(`[New Msg] 來自: ${senderName} | 內容: ${content}`);
        
        // 更新 Checkpoint
        chatCheckpoints[chatId] = msgId;

        // --- 呼叫 LLM 並回覆 (Echo 範例) ---
        if (content) {
            const replyText = `Bot 回覆 ${senderName}: ${content}`;
            const htmlReply = marked.parse(replyText); // 轉 HTML

            await axios.post(`${GRAPH_ENDPOINT}/chats/${chatId}/messages`, {
                body: { contentType: 'html', content: htmlReply }
            }, { headers: { 'Authorization': `Bearer ${token}` } });
            
            console.log(`[Reply] 已回覆給 ${senderName}`);
        }

    } catch (e) {
        console.error(`處理聊天室 ${chatId} 失敗:`, e.message);
    }
}

// 5. [核心] 巡邏主程式
async function pollAllChats() {
    const token = await getGraphToken_ROPC();
    if (!token) return;

    if (!myUserId) await getMyUserId(token);

    try {
        // [關鍵 API] 取得所有聊天室，按最後更新時間排序，只抓前 10 個有動靜的
        // 這樣可以避免一次抓幾百個聊天室導致效能問題
        const listUrl = `${GRAPH_ENDPOINT}/chats?$orderby=lastUpdatedDateTime desc&$top=10`;
        const listRes = await axios.get(listUrl, { headers: { 'Authorization': `Bearer ${token}` } });
        
        const activeChats = listRes.data.value;

        // 平行處理這些有動靜的聊天室
        const promises = activeChats.map(chat => {
            return processChatMessages(token, chat.id);
        });

        await Promise.all(promises);

    } catch (e) {
        console.error("巡邏聊天室列表失敗:", e.message);
    }
}

// 6. 啟動
console.log("多聊天室 Polling Bot 已啟動...");
setInterval(pollAllChats, parseInt(POLL_INTERVAL_MS || 5000));
pollAllChats();
原理講解：為什麼這樣做可以擴充？
GET /chats?$orderby=lastUpdatedDateTime desc&$top=10

這是魔法所在。這行指令會問 Teams：「請給我最近有更新的前 10 個聊天室」。

無論您有 100 個還是 1000 個使用者，只要有人傳訊息，那個聊天室就會瞬間「浮」到這個列表的最上面。

Robot 只需要盯著這「前 10 名」看就好了，效率非常高。

chatCheckpoints (記憶體)

我們用一個簡單的物件來記住每個聊天室我們讀到了哪裡。

{ "Chat_A": "Msg_101", "Chat_B": "Msg_55" }

當 Robot 再次巡邏到 Chat_A 時，發現最新訊息還是 Msg_101，它就知道「沒事，略過」，不會重複回覆。

自動探索 (Auto Discovery)

當一個新使用者第一次搜尋並傳訊息給 Robot 時，Teams 會建立一個新聊天室，並更新 lastUpdatedDateTime。

Robot 下一次 polling 時，這個新聊天室會出現在列表第一位。

程式碼自動取得它的 id，然後開始處理。

結論： 您完全不需要手動建立聊天室，讓使用者來找 Robot 即可。

如果 Robot 真的需要「主動」找人呢？
只有在 Robot 想發起對話（例如：發送每日通知），而對方從來沒跟 Robot 講過話時，您才需要「建立聊天室」。

API 是： POST /chats Body:

JSON

{
  "chatType": "oneOnOne",
  "members": [
    {
      "roles": ["owner"],
      "user": { "id": "Robot的User_ID" }
    },
    {
      "roles": ["owner"],
      "user": { "userPrincipalName": "user@mycompany.com" } // 對方的 Email
    }
  ]
}
呼叫成功後，它會回傳一個 id，您就可以用那個 ID 去發訊息了。但通常做客服機器人，被動等待使用者來敲是比較好的設計。
