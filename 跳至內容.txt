這是一個非常實用的功能。要在 Teams 中透過 Graph API 接收並下載圖片，核心觀念只有一個：

圖片的 URL 是受保護的，下載時必須帶上 Authorization: Bearer {token}。

您不能直接用瀏覽器開啟那個圖片連結（會看到 401 錯誤），您的程式碼必須像呼叫 API 一樣去下載它。

Teams 中的圖片主要分兩種：

內嵌圖片 (Hosted Content): 使用者直接貼上 (Paste) 的截圖。它的 URL 藏在 body.content 的 HTML <img> 標籤中。

附件圖片 (Attachments): 使用者透過迴紋針上傳的圖片。它的 URL 在 attachments 陣列中。

為了簡化，我會提供一段程式碼，同時處理這兩種情況，並將它們下載為 .jpg。

修改步驟
您需要修改 polling-bot.js，加入 fs (檔案系統) 模組，並新增一個 downloadImage 函式。

1. 引入必要的模組 (檔案最上方)
JavaScript

// ... 原本的 require ...
const fs = require('fs');
const path = require('path');
const https = require('https'); // 用於下載
// ...
2. 新增 downloadImage 輔助函式
請將此函式放在 pollMessages 函式外面（例如檔案最下方）。

JavaScript

// 下載圖片的輔助函式
async function downloadImage(url, token, folder = './downloads') {
    try {
        // 1. 確保下載資料夾存在
        if (!fs.existsSync(folder)) {
            fs.mkdirSync(folder);
        }

        // 2. 產生檔名 (使用時間戳記，避免重複)
        const filename = `image_${Date.now()}_${Math.floor(Math.random() * 1000)}.jpg`;
        const filepath = path.join(folder, filename);

        console.log(`[Download] 正在下載圖片... URL: ${url}`);

        // 3. 發送 GET 請求 (關鍵：必須帶 Token，並設定 responseType 為 stream)
        const response = await axios({
            method: 'GET',
            url: url,
            responseType: 'stream',
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        // 4. 寫入檔案
        const writer = fs.createWriteStream(filepath);
        response.data.pipe(writer);

        return new Promise((resolve, reject) => {
            writer.on('finish', () => {
                console.log(`[Download] 圖片已儲存: ${filepath}`);
                resolve(filepath);
            });
            writer.on('error', reject);
        });

    } catch (error) {
        console.error(`[Download] 下載失敗:`, error.message);
    }
}
3. 修改 pollMessages 函式邏輯
在您原本處理 if (messageContent) { ... } 的地方，加入偵測圖片的邏輯。

請找到 // --- 處理新訊息 --- 區塊，並替換成以下邏輯：

JavaScript

        // ... (前面省略) ...
        console.log('--- [Polling] 偵測到新訊息 ---');
        
        const senderName = (latestMessage.from && latestMessage.from.user) ? latestMessage.from.user.displayName : '未知使用者';
        console.log(`使用者: ${senderName}`);

        const messageContent = (latestMessage.body.content || '').replace(/<[^>]*>/g, '').trim();

        // ---------------------------------------------------------
        // [新增] 圖片處理邏輯
        // ---------------------------------------------------------
        
        // 情境 A: 內嵌圖片 (直接貼上的)
        // Teams 會在 body 中包含 <img src="...">
        // 我們用 Regex 抓出 src 屬性
        const imgRegex = /<img[^>]+src="([^">]+)"/g;
        let match;
        const downloadPromises = [];

        // 掃描所有 <img> 標籤
        while ((match = imgRegex.exec(latestMessage.body.content)) !== null) {
            const hostedContentUrl = match[1];
            // Teams 的 hosted content URL 通常是 graph.microsoft.com/.../$value
            // 它是受保護的資源，需要 Token
            downloadPromises.push(downloadImage(hostedContentUrl, token));
        }

        // 情境 B: 附件圖片 (上傳的)
        if (latestMessage.attachments && latestMessage.attachments.length > 0) {
            for (const attachment of latestMessage.attachments) {
                // 確保這是圖片，且有下載連結
                if (attachment.contentType && attachment.contentType.startsWith('image/') && attachment.contentUrl) {
                    downloadPromises.push(downloadImage(attachment.contentUrl, token));
                }
            }
        }

        // 等待所有圖片下載完成
        if (downloadPromises.length > 0) {
            await Promise.all(downloadPromises);
            console.log(`[System] 共下載了 ${downloadPromises.length} 張圖片`);
        }
        // ---------------------------------------------------------


        if (messageContent) {
            console.log(`文字訊息: ${messageContent}`);
            
            // ... (原本的回覆邏輯 send reply ...) ...
            try {
                const replyUrl = `${GRAPH_ENDPOINT}/chats/${CHAT_ID}/messages`;
                const replyPayload = {
                    body: { content: `Bot Echo: ${messageContent}` }
                };
                await axios.post(replyUrl, replyPayload, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                console.log("--- [Polling] 已成功回覆訊息! ---");
            } catch (replyError) {
                console.error("--- [Polling] 回覆訊息時失敗:", replyError.response ? replyError.response.data : replyError.message);
            }

        } else if (downloadPromises.length > 0) {
            // 如果只有圖片沒有文字
            console.log(`訊息: [純圖片訊息]`);
             // 您也可以在這裡加一個 "收到圖片了" 的回覆
        } else {
            console.log(`訊息: [訊息為空或無法辨識]`);
        }
        
        // ... (後面省略) ...
