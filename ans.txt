
require('dotenv').config();
const msal = require('@azure/msal-node');
const axios = require('axios');

// 1. 從 .env 讀取設定
const {
    CLIENT_ID,
    CLIENT_SECRET,
    TENANT_ID,
    CHAT_ID,
    POLL_INTERVAL_MS
} = process.env;

if (!CLIENT_ID || !CLIENT_SECRET || !TENANT_ID || !CHAT_ID) {
    console.error("錯誤：.env 檔案中的 CLIENT_ID, CLIENT_SECRET, TENANT_ID 或 CHAT_ID 缺少設定。");
    process.exit(1);
}

const AUTHORITY = `https://login.microsoftonline.com/${TENANT_ID}`;
const GRAPH_ENDPOINT = 'https://graph.microsoft.com/v1.0';

// 2. MSAL (驗證) 設定
const msalConfig = {
    auth: {
        clientId: CLIENT_ID,
        authority: AUTHORITY,
        clientSecret: CLIENT_SECRET,
    },
};
const cca = new msal.ConfidentialClientApplication(msalConfig);

// 3. 取得 Graph API Access Token 的輔助函式
async function getGraphToken() {
    try {
        const response = await cca.acquireTokenByClientCredential({
            scopes: ['https://graph.microsoft.com/.default'],
        });
        return response.accessToken;
    } catch (error) {
        console.error("取得 Token 失敗，詳細錯誤:", error);
        return null;
    }
}

// 4. 變數：儲存最後處理的訊息 ID
let lastProcessedMessageId = null;

// 5. 核心：輪詢函式
async function pollMessages() {
    const token = await getGraphToken();
    if (!token) {
        console.log("[Polling] 無法取得 Token，5秒後重試...");
        return;
    }

    try {
        const url = `${GRAPH_ENDPOINT}/chats/${CHAT_ID}/messages?$orderby=createdDateTime desc&$top=1`;
        const response = await axios.get(url, { headers: { 'Authorization': `Bearer ${token}` }});

        const messages = response.data.value;
        if (!messages || messages.length === 0) {
            return;
        }

        const latestMessage = messages[0];
        const messageId = latestMessage.id;
        
        if (messageId === lastProcessedMessageId) {
            return; 
        }

        const sender = latestMessage.from;
        let isFromMyBot = false;
        
        if (sender && sender.application && sender.application.id === CLIENT_ID) {
            isFromMyBot = true;
        }
        
        if (isFromMyBot) {
            console.log("[Polling] 忽略自己(Application)發送的訊息...");
            lastProcessedMessageId = messageId;
            return;
        }

        // --- 處理新訊息 ---
        console.log('--- [Polling] 偵測到新訊息 ---');
        
        const senderName = (latestMessage.from && latestMessage.from.user) ? latestMessage.from.user.displayName : '未知使用者';
        console.log(`使用者: ${senderName}`);

        const messageContent = (latestMessage.body.content || '').replace(/<[^>]*>/g, '').trim();

        if (messageContent) {
            console.log(`訊息: ${messageContent}`);

            // --- [NEW CODE START] ---
            // 將收到的訊息"回音" (Echo) 回去
            try {
                const replyUrl = `${GRAPH_ENDPOINT}/chats/${CHAT_ID}/messages`;
                
                const replyPayload = {
                    body: {
                        // 我們將收到的純文字訊息 (messageContent) 再包裝成 HTML 傳回
                        content: `Bot Echo: ${messageContent}`
                    }
                };

                await axios.post(replyUrl, replyPayload, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                console.log("--- [Polling] 已成功回覆訊息! ---");

            } catch (replyError) {
                console.error("--- [Polling] 回覆訊息時失敗:", replyError.response ? replyError.response.data : replyError.message);
            }
            // --- [NEW CODE END] ---
        
        } else if (latestMessage.attachments && latestMessage.attachments.length > 0) {
            console.log(`訊息: [附件訊息 (例如: 圖片, GIF, 檔案)]`);
        } else if (latestMessage.messageType === 'systemEventMessage') {
            console.log(`訊息: [系統訊息 (例如: 新增成員)]`);
        } else {
            console.log(`訊息: [訊息為空或無法辨識]`);
        }
        
        console.log('--------------------------------');

        lastProcessedMessageId = messageId;

    } catch (error) {
        if (error.response && error.response.status === 404) {
             console.error(`[Polling] 輪詢 Graph API 失敗: 404 Not Found。`);
             console.error(`  請再次確認您的 .env 檔案中的 CHAT_ID: "${CHAT_ID}" 是否正確。`);
             clearInterval(pollingInterval);
        } else if (error.response && error.response.status === 401) {
            console.error("[Polling] 輪詢 Graph API 失敗: 401 Unauthorized。請檢查您的 Token 權限。");
        } else {
            console.error("[Polling] 輪詢 Graph API 時出錯:", error.message || (error.response ? error.response.data : error));
        }
    }
}

// 6. 啟動輪詢迴圈
console.log(`[Polling] 輪詢 Bot 已啟動，監聽 Chat ID: ${CHAT_ID}`);
console.log(`輪詢間隔: ${POLL_INTERVAL_MS / 1000} 秒`);

pollMessages();
const pollingInterval = setInterval(pollMessages, parseInt(POLL_INTERVAL_MS || 5000));
